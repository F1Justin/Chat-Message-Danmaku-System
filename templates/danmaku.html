<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>群聊弹幕</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: transparent;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', 'Microsoft YaHei', 
                         'Segoe UI', 'Helvetica Neue', Ubuntu, 'Noto Sans', sans-serif;
        }
        
        #danmaku-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }
        
        #debug-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            padding: 10px 15px;
            border-radius: 6px;
            z-index: 1000;
            display: none;
            min-width: 200px;
        }
        
        #debug-panel.visible { display: block; }
        
        .debug-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        
        .debug-label { color: #888; }
        .debug-value { color: #0f0; font-weight: bold; }
        .debug-value.warning { color: #ff0; }
        .debug-value.error { color: #f00; }
    </style>
</head>
<body>
    <canvas id="danmaku-canvas"></canvas>
    
    <div id="debug-panel">
        <div class="debug-row">
            <span class="debug-label">FPS:</span>
            <span class="debug-value" id="debug-fps">0</span>
        </div>
        <div class="debug-row">
            <span class="debug-label">弹幕数:</span>
            <span class="debug-value" id="debug-count">0</span>
        </div>
        <div class="debug-row">
            <span class="debug-label">连接:</span>
            <span class="debug-value" id="debug-ws">断开</span>
        </div>
        <div class="debug-row">
            <span class="debug-label">过滤:</span>
            <span class="debug-value" id="debug-filter">关闭</span>
        </div>
    </div>

    <script>
    /**
     * Canvas 弹幕渲染引擎
     * 高性能弹幕系统，使用 Canvas 2D 渲染
     */
    
    // ============================================================
    // 配置
    // ============================================================
    
    const Config = {
        // 弹幕设置
        fontSize: 48,
        fontFamily: "'PingFang SC', 'Microsoft YaHei', sans-serif",
        fontWeight: 'bold',
        maxDanmaku: 150,
        speedSeconds: 10,  // 弹幕穿越屏幕的秒数
        
        // 轨道设置
        trackHeight: 60,   // 每个轨道高度
        trackPadding: 10,  // 轨道间距
        
        // 视觉设置
        shadowBlur: 4,
        shadowColor: 'rgba(0, 0, 0, 0.8)',
        strokeWidth: 3,
        strokeColor: '#000',
        
        // 调试
        showDebug: false,
        
        // 颜色映射
        colors: {
            '红': '#FF3B2F',
            '橙': '#FF9500',
            '黄': '#FFCC02',
            '绿': '#35C759',
            '蓝': '#31ADE6',
            '靛': '#5856D7',
            '紫': '#AF52DE',
            '灰': '#9E9E9E'
        },
        
        // 需要白色描边的深色
        darkColors: new Set(['#5856D7', '#AF52DE', '#35C759', '#31ADE6'])
    };
    
    // ============================================================
    // 弹幕类
    // ============================================================
    
    class Danmaku {
        constructor(text, options = {}) {
            this.text = text;
            this.messageId = options.messageId || null;
            this.userId = options.userId || null;
            this.groupId = options.groupId || null;
            
            // 解析命令
            const parsed = this.parseCommands(text);
            this.displayText = parsed.content;
            this.color = parsed.color || '#FFFFFF';
            this.position = parsed.position || 'scroll';  // 'scroll', 'top', 'bottom'
            this.needsLightStroke = parsed.needsLightStroke || false;
            
            // 位置和速度
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.speed = 0;
            this.track = -1;
            
            // 状态
            this.alive = true;
            this.createdAt = performance.now();
            
            // 固定弹幕的显示时间
            this.fixedDuration = options.fixedDuration || 5000;
        }
        
        parseCommands(text) {
            const result = {
                content: text,
                color: null,
                position: null,
                needsLightStroke: false
            };
            
            const parts = text.split(' ');
            if (parts.length <= 1) return result;
            
            const contentParts = [parts[0]];
            const positionMap = { '居中': 'top', '下居中': 'bottom' };
            
            for (let i = 1; i < parts.length; i++) {
                const part = parts[i];
                
                if (positionMap[part]) {
                    result.position = positionMap[part];
                } else if (Config.colors[part]) {
                    result.color = Config.colors[part];
                    if (Config.darkColors.has(result.color)) {
                        result.needsLightStroke = true;
                    }
                } else {
                    contentParts.push(part);
                }
            }
            
            result.content = contentParts.join(' ');
            return result;
        }
        
        update(deltaTime) {
            if (!this.alive) return;
            
            if (this.position === 'scroll') {
                // 滚动弹幕
                this.x -= this.speed * deltaTime;
                if (this.x + this.width < 0) {
                    this.alive = false;
                }
            } else {
                // 固定弹幕
                const elapsed = performance.now() - this.createdAt;
                if (elapsed > this.fixedDuration) {
                    this.alive = false;
                }
            }
        }
        
        render(ctx) {
            if (!this.alive) return;
            
            ctx.save();
            
            // 设置字体
            ctx.font = `${Config.fontWeight} ${Config.fontSize}px ${Config.fontFamily}`;
            ctx.textBaseline = 'top';
            
            // 阴影
            ctx.shadowBlur = Config.shadowBlur;
            ctx.shadowColor = Config.shadowColor;
            
            // 描边
            if (this.needsLightStroke) {
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
            } else {
                ctx.strokeStyle = Config.strokeColor;
                ctx.lineWidth = Config.strokeWidth;
            }
            ctx.lineJoin = 'round';
            ctx.strokeText(this.displayText, this.x, this.y);
            
            // 填充
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 0;
            ctx.fillText(this.displayText, this.x, this.y);
            
            ctx.restore();
        }
    }
    
    // ============================================================
    // 弹幕引擎
    // ============================================================
    
    class DanmakuEngine {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            
            this.danmakus = [];
            this.tracks = [];  // 轨道占用状态
            this.processedIds = new Set();
            
            // 性能统计
            this.lastFrameTime = 0;
            this.frameCount = 0;
            this.fps = 0;
            this.fpsUpdateTime = 0;
            
            // 过滤设置
            this.filterEnabled = false;
            this.allowedGroups = new Set();
            
            // 初始化
            this.resize();
            this.initTracks();
            
            // 事件监听
            window.addEventListener('resize', () => this.resize());
            
            // 启动渲染循环
            this.running = true;
            requestAnimationFrame((t) => this.loop(t));
        }
        
        resize() {
            const dpr = window.devicePixelRatio || 1;
            const rect = this.canvas.getBoundingClientRect();
            
            this.canvas.width = rect.width * dpr;
            this.canvas.height = rect.height * dpr;
            
            this.ctx.scale(dpr, dpr);
            
            this.width = rect.width;
            this.height = rect.height;
            
            this.initTracks();
        }
        
        initTracks() {
            const trackCount = Math.floor(this.height / (Config.trackHeight + Config.trackPadding));
            this.tracks = new Array(trackCount).fill(0);  // 存储每个轨道的结束时间
        }
        
        findAvailableTrack() {
            const now = performance.now();
            for (let i = 0; i < this.tracks.length; i++) {
                if (this.tracks[i] <= now) {
                    return i;
                }
            }
            // 如果没有空轨道，返回最早释放的轨道
            let minIndex = 0;
            let minTime = this.tracks[0];
            for (let i = 1; i < this.tracks.length; i++) {
                if (this.tracks[i] < minTime) {
                    minTime = this.tracks[i];
                    minIndex = i;
                }
            }
            return minIndex;
        }
        
        add(text, options = {}) {
            // 检查消息ID是否已处理
            if (options.messageId && this.processedIds.has(options.messageId)) {
                return null;
            }
            
            // 检查过滤
            if (this.filterEnabled && options.groupId) {
                if (!this.allowedGroups.has(String(options.groupId))) {
                    return null;
                }
            }
            
            // 检查数量限制
            if (this.danmakus.length >= Config.maxDanmaku) {
                // 移除最老的弹幕
                this.danmakus.shift();
            }
            
            const danmaku = new Danmaku(text, options);
            
            // 测量文本宽度
            this.ctx.font = `${Config.fontWeight} ${Config.fontSize}px ${Config.fontFamily}`;
            danmaku.width = this.ctx.measureText(danmaku.displayText).width;
            
            if (danmaku.position === 'scroll') {
                // 滚动弹幕
                danmaku.x = this.width;
                
                // 分配轨道
                danmaku.track = this.findAvailableTrack();
                danmaku.y = danmaku.track * (Config.trackHeight + Config.trackPadding) + Config.trackPadding;
                
                // 计算速度（像素/毫秒）
                const totalDistance = this.width + danmaku.width;
                danmaku.speed = totalDistance / (Config.speedSeconds * 1000);
                
                // 更新轨道占用时间
                // 计算弹幕完全进入屏幕的时间
                const enterTime = danmaku.width / danmaku.speed;
                this.tracks[danmaku.track] = performance.now() + enterTime + 100;  // 加100ms间隔
                
            } else if (danmaku.position === 'top') {
                // 顶部居中
                danmaku.x = (this.width - danmaku.width) / 2;
                danmaku.y = Config.trackPadding;
                
            } else if (danmaku.position === 'bottom') {
                // 底部居中
                danmaku.x = (this.width - danmaku.width) / 2;
                danmaku.y = this.height - Config.fontSize - Config.trackPadding;
            }
            
            this.danmakus.push(danmaku);
            
            // 记录消息ID
            if (options.messageId) {
                this.processedIds.add(options.messageId);
                // 限制已处理ID的数量
                if (this.processedIds.size > 1000) {
                    const idsArray = Array.from(this.processedIds);
                    this.processedIds = new Set(idsArray.slice(-500));
                }
            }
            
            return danmaku;
        }
        
        clear() {
            this.danmakus = [];
            this.processedIds.clear();
            this.initTracks();
        }
        
        setFilter(enabled, groups) {
            this.filterEnabled = enabled;
            this.allowedGroups = new Set((groups || []).map(String));
            
            // 如果启用过滤且没有允许的群组，清空弹幕
            if (enabled && this.allowedGroups.size === 0) {
                this.clear();
            }
        }
        
        setSpeed(seconds) {
            if (seconds >= 5 && seconds <= 60) {
                Config.speedSeconds = seconds;
            }
        }
        
        loop(currentTime) {
            if (!this.running) return;
            
            // 计算时间差
            const deltaTime = this.lastFrameTime ? currentTime - this.lastFrameTime : 16;
            this.lastFrameTime = currentTime;
            
            // 更新FPS
            this.frameCount++;
            if (currentTime - this.fpsUpdateTime >= 1000) {
                this.fps = this.frameCount;
                this.frameCount = 0;
                this.fpsUpdateTime = currentTime;
                this.updateDebugPanel();
            }
            
            // 清空画布
            this.ctx.clearRect(0, 0, this.width, this.height);
            
            // 更新和渲染弹幕
            for (let i = this.danmakus.length - 1; i >= 0; i--) {
                const danmaku = this.danmakus[i];
                danmaku.update(deltaTime);
                
                if (!danmaku.alive) {
                    this.danmakus.splice(i, 1);
                } else {
                    danmaku.render(this.ctx);
                }
            }
            
            requestAnimationFrame((t) => this.loop(t));
        }
        
        updateDebugPanel() {
            if (!Config.showDebug) return;
            
            document.getElementById('debug-fps').textContent = this.fps;
            document.getElementById('debug-count').textContent = this.danmakus.length;
        }
        
        destroy() {
            this.running = false;
            this.clear();
        }
    }
    
    // ============================================================
    // WebSocket 客户端
    // ============================================================
    
    class WebSocketClient {
        constructor(engine) {
            this.engine = engine;
            this.socket = null;
            this.reconnectAttempts = 0;
            this.maxReconnectAttempts = 10;
            this.reconnectDelay = 3000;
        }
        
        connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const url = `${protocol}//${location.host}/ws`;
            
            console.log(`[WS] 连接到 ${url}`);
            this.socket = new WebSocket(url);
            
            this.socket.onopen = () => {
                console.log('[WS] 连接成功');
                this.reconnectAttempts = 0;
                this.updateConnectionStatus(true);
            };
            
            this.socket.onmessage = (event) => {
                this.handleMessage(event.data);
            };
            
            this.socket.onclose = (event) => {
                console.log(`[WS] 连接关闭: ${event.code}`);
                this.updateConnectionStatus(false);
                this.scheduleReconnect();
            };
            
            this.socket.onerror = (error) => {
                console.error('[WS] 错误:', error);
            };
        }
        
        handleMessage(data) {
            try {
                const msg = JSON.parse(data);
                
                switch (msg.type) {
                    case 'danmaku':
                        this.engine.add(msg.content, {
                            messageId: msg.message_id,
                            userId: msg.user_id,
                            groupId: msg.group_id
                        });
                        break;
                        
                    case 'connection':
                        console.log('[WS] 连接确认:', msg.message);
                        if (msg.settings?.danmaku_speed) {
                            this.engine.setSpeed(msg.settings.danmaku_speed);
                        }
                        break;
                        
                    case 'broadcast_filter_update':
                        console.log('[WS] 过滤器更新:', msg);
                        this.engine.setFilter(msg.filter_enabled, msg.allowed_groups);
                        this.updateFilterStatus(msg.filter_enabled, msg.allowed_groups);
                        break;
                        
                    case 'setting_update':
                        if (msg.key === 'danmaku_speed') {
                            this.engine.setSpeed(msg.value);
                        } else if (msg.settings) {
                            this.applySettings(msg.settings);
                        }
                        break;
                        
                    case 'stats':
                        // 统计信息
                        break;
                }
            } catch (e) {
                console.error('[WS] 消息解析错误:', e);
            }
        }
        
        applySettings(settings) {
            if (settings.fontSize) {
                Config.fontSize = settings.fontSize;
            }
            if (settings.maxDanmaku) {
                Config.maxDanmaku = settings.maxDanmaku;
            }
        }
        
        scheduleReconnect() {
            if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                console.log('[WS] 达到最大重连次数');
                return;
            }
            
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1);
            
            console.log(`[WS] ${delay}ms 后重连 (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
            
            setTimeout(() => this.connect(), delay);
        }
        
        updateConnectionStatus(connected) {
            const el = document.getElementById('debug-ws');
            if (el) {
                el.textContent = connected ? '已连接' : '断开';
                el.className = 'debug-value' + (connected ? '' : ' error');
            }
        }
        
        updateFilterStatus(enabled, groups) {
            const el = document.getElementById('debug-filter');
            if (el) {
                if (enabled && groups?.length > 0) {
                    el.textContent = `${groups.length}个群`;
                    el.className = 'debug-value';
                } else {
                    el.textContent = enabled ? '空' : '关闭';
                    el.className = 'debug-value' + (enabled ? ' warning' : '');
                }
            }
        }
        
        send(data) {
            if (this.socket?.readyState === WebSocket.OPEN) {
                this.socket.send(JSON.stringify(data));
            }
        }
    }
    
    // ============================================================
    // 初始化
    // ============================================================
    
    let engine, wsClient;
    
    window.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('danmaku-canvas');
        engine = new DanmakuEngine(canvas);
        wsClient = new WebSocketClient(engine);
        
        // 检查URL参数
        const params = new URLSearchParams(location.search);
        if (params.get('debug') === 'true') {
            Config.showDebug = true;
            document.getElementById('debug-panel').classList.add('visible');
        }
        
        // 连接WebSocket
        wsClient.connect();
        
        // 监听来自控制面板的消息
        window.addEventListener('message', (event) => {
            const data = event.data;
            if (!data?.action) return;
            
            switch (data.action) {
                case 'showRecentMessages':
                    engine.clear();
                    data.messages?.forEach(msg => {
                        engine.add(msg.content, {
                            messageId: msg.message_id,
                            userId: msg.user_id,
                            groupId: msg.group_id
                        });
                    });
                    break;
                    
                case 'newDanmaku':
                    engine.add(data.message.content, {
                        messageId: data.message.message_id,
                        userId: data.message.user_id,
                        groupId: data.message.group_id
                    });
                    break;
                    
                case 'clearDanmaku':
                    engine.clear();
                    break;
                    
                case 'updateSettings':
                    wsClient.applySettings(data.settings);
                    break;
                    
                case 'setFilter':
                    engine.setFilter(data.enabled, data.allowed_groups);
                    break;
            }
        });
        
        // 通知父窗口已准备好
        if (window.parent !== window) {
            window.parent.postMessage({ type: 'previewReady' }, '*');
        }
        
        // 定期向父窗口报告状态
        setInterval(() => {
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'danmakuStats',
                    count: engine.danmakus.length
                }, '*');
            }
        }, 1000);
    });
    
    // 清理
    window.addEventListener('beforeunload', () => {
        engine?.destroy();
    });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>群聊弹幕</title>
    <style>
        :root {
            --danmaku-font-size: 32px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', 'Microsoft YaHei', 'Segoe UI', 'Helvetica Neue', Ubuntu, 'Noto Sans', 'Source Han Sans CN', 'Source Han Sans SC', sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        .danmaku {
            position: absolute;
            white-space: nowrap;
            font-size: var(--danmaku-font-size);
            font-weight: bold;
            text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000;
            will-change: transform, left;
            user-select: none;
            z-index: 10;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            transform: translateZ(0);
            pointer-events: none;
        }
        
        #debug-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="debug-info">弹幕数: <span id="danmaku-count">0</span></div>
    
    <script>
        // 配置
        const container = document.getElementById('container');
        const debugInfo = document.getElementById('debug-info');
        const danmakuCountElement = document.getElementById('danmaku-count');
        let activeDanmaku = 0;
        let maxDanmaku = 50;  // 最大同时显示的弹幕数
        let danmakuFontSize = 32;  // 默认弹幕字体大小
        let animationMethod = 'transform';  // 默认使用transform动画
        let isDebugMode = false;  // 调试模式
        
        // 显示调试信息
        function toggleDebug() {
            isDebugMode = !isDebugMode;
            debugInfo.style.display = isDebugMode ? 'block' : 'none';
        }
        
        // 创建弹幕元素
        function createDanmaku(text, userId, messageId) {
            // 检查活跃弹幕数量，如果超过最大数量，直接返回
            if (activeDanmaku >= maxDanmaku) {
                console.log('已达最大弹幕数量，丢弃新弹幕');
                return;
            }
            
            // 防止XSS
            const safeText = String(text).replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const trackHeight = container.clientHeight - danmakuFontSize;
            
            const danmaku = document.createElement('div');
            danmaku.className = 'danmaku';
            danmaku.innerHTML = safeText;
            danmaku.style.fontSize = `${danmakuFontSize}px`;
            danmaku.setAttribute('data-message-id', messageId || '');
            
            // 随机颜色
            const colors = [
                '#FFFFFF', // 白色
                '#FF8C00', // 深橙色
                '#FFD700', // 金色
                '#00BFFF', // 深天蓝
                '#7FFF00', // 查特酸绿
                '#FF69B4', // 热粉红
                '#00FFFF', // 青色
                '#F0E68C', // 卡其色
                '#FFA07A', // 浅鲑鱼色
                '#00FA9A'  // 中春绿色
            ];
            
            // 使用用户ID来选择一个固定的颜色（如果有userId）
            let colorIndex = 0;
            if (userId) {
                const userHash = String(userId).split('').reduce((a, b) => {
                    return a + b.charCodeAt(0);
                }, 0);
                colorIndex = userHash % colors.length;
            } else {
                colorIndex = Math.floor(Math.random() * colors.length);
            }
            
            danmaku.style.color = colors[colorIndex];
            
            // 随机垂直位置
            const top = Math.floor(Math.random() * trackHeight);
            danmaku.style.top = `${top}px`;
            
            // 添加到容器
            container.appendChild(danmaku);
            
            // 获取宽度
            const danmakuWidth = danmaku.offsetWidth;
            
            // 设置初始位置（确保在屏幕右侧外）
            const containerWidth = container.clientWidth;
            const startPosition = containerWidth;
            const endPosition = -danmakuWidth;
            
            // 根据文本长度计算动画持续时间：短消息更快，长消息更慢
            // 基础速度：每秒移动屏幕宽度的15%（约6-7秒穿过屏幕）
            const baseDuration = 6000;
            // 文本长度影响系数：每多10个字符增加0.5秒时间
            const lengthFactor = Math.min(3000, Math.max(0, safeText.length * 50));
            const duration = baseDuration + lengthFactor;
            
            console.log(`弹幕: "${safeText.substring(0, 20)}${safeText.length > 20 ? '...' : ''}" 宽度=${danmakuWidth}px, 持续时间=${duration}ms`);
            
            // 增加活跃弹幕计数
            activeDanmaku++;
            updateDanmakuCount();
            
            if (animationMethod === 'transform') {
                // 确保弹幕起始位置在屏幕外右侧
                danmaku.style.transform = `translateX(${startPosition}px)`;
                
                // 强制浏览器重绘，以确保起始位置已应用
                void danmaku.offsetWidth;
                
                // 设置过渡属性，确保动画流畅
                danmaku.style.transition = `transform ${duration}ms linear`;
                
                // 设置延迟，确保上一步的样式已应用
                requestAnimationFrame(() => {
                    // 开始动画，移动到目标位置
                    danmaku.style.transform = `translateX(${endPosition}px)`;
                    
                    // 动画结束后移除弹幕
                    setTimeout(() => {
                        if (danmaku && danmaku.parentNode) {
                            danmaku.parentNode.removeChild(danmaku);
                            activeDanmaku--;
                            updateDanmakuCount();
                        }
                    }, duration + 200); // 增加延迟确保动画完成后再移除
                });
            } else {
                // 使用left属性实现动画(兼容性更好但性能较差)
                danmaku.style.left = `${startPosition}px`;
                
                // 创建动画帧
                let startTime = null;
                
                function animateFrame(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const elapsed = timestamp - startTime;
                    
                    if (elapsed < duration) {
                        const progress = elapsed / duration;
                        const currentPos = startPosition - progress * (startPosition - endPosition);
                        danmaku.style.left = `${currentPos}px`;
                        requestAnimationFrame(animateFrame);
                    } else {
                        // 动画结束，移除弹幕
                        if (danmaku && danmaku.parentNode) {
                            danmaku.parentNode.removeChild(danmaku);
                            activeDanmaku--;
                            updateDanmakuCount();
                        }
                    }
                }
                
                // 启动动画
                requestAnimationFrame(animateFrame);
            }
        }
        
        // 更新弹幕计数显示
        function updateDanmakuCount() {
            danmakuCountElement.textContent = activeDanmaku;
            
            // 向父窗口报告弹幕数量（用于控制台显示）
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'danmakuStats',
                    count: activeDanmaku
                }, '*');
            }
        }
        
        // 清空所有弹幕
        function clearDanmaku() {
            container.innerHTML = '';
            activeDanmaku = 0;
            updateDanmakuCount();
        }
        
        // 应用设置
        function applySettings(settings) {
            if (settings.fontSize && typeof settings.fontSize === 'number') {
                danmakuFontSize = settings.fontSize;
                document.documentElement.style.setProperty('--danmaku-font-size', `${danmakuFontSize}px`);
                console.log(`字体大小已更新为 ${danmakuFontSize}px`);
            }
            
            if (settings.maxDanmaku && typeof settings.maxDanmaku === 'number') {
                maxDanmaku = settings.maxDanmaku;
                console.log(`最大弹幕数已更新为 ${maxDanmaku}`);
            }
            
            if (settings.animationMethod) {
                animationMethod = settings.animationMethod;
                console.log(`动画方式已更新为 ${animationMethod}`);
            }
            
            // 更新所有现有弹幕的字体大小
            document.querySelectorAll('.danmaku').forEach(element => {
                element.style.fontSize = `${danmakuFontSize}px`;
            });
        }
        
        // WebSocket连接
        let socket = null;
        let reconnectInterval = 1000;  // 初始重连间隔为1秒
        let isReconnecting = false;
        let isFullscreen = window.self === window.top; // 判断是否为全屏独立窗口
        let processedMessages = new Set(); // 存储已处理的消息ID，避免重复
        
        // 连接WebSocket
        function connectWebSocket() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log('WebSocket已连接');
                return;
            }
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            console.log(`正在连接WebSocket: ${wsUrl}`);
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function() {
                console.log('WebSocket连接已建立');
                reconnectInterval = 1000;  // 重置重连间隔
                isReconnecting = false;
                
                // 设置群聊过滤（如果URL中有group参数）
                const urlParams = new URLSearchParams(window.location.search);
                const groupId = urlParams.get('group');
                if (groupId) {
                    socket.send(JSON.stringify({
                        type: 'command',
                        action: 'set_groups',
                        filter_enabled: true,
                        groups: [groupId]
                    }));
                    console.log(`已设置过滤群聊: ${groupId}`);
                    
                    // 连接成功后请求最近消息
                    requestRecentMessages(groupId);
                }
            };
            
            socket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('收到WebSocket消息:', data);
                    
                    if (data.type === 'danmaku') {
                        // 检查是否已处理过该消息
                        if (data.message_id && processedMessages.has(data.message_id)) {
                            console.log(`跳过重复消息: ${data.message_id}`);
                            return;
                        }
                        
                        // 添加到已处理集合
                        if (data.message_id) {
                            processedMessages.add(data.message_id);
                        }
                        
                        // 处理弹幕消息
                        createDanmaku(data.content, data.user_id, data.message_id);
                    } else if (data.type === 'settings') {
                        // 处理设置消息
                        console.log('收到设置更新:', data.settings);
                        applySettings(data.settings);
                    }
                } catch (e) {
                    console.error('处理WebSocket消息时出错:', e);
                }
            };
            
            socket.onclose = function(event) {
                if (!isReconnecting) {
                    console.log(`WebSocket连接已关闭，代码：${event.code}，原因：${event.reason || '未知'}`);
                    isReconnecting = true;
                    
                    // 指数退避重连
                    console.log(`将在 ${reconnectInterval}ms 后重新连接...`);
                    setTimeout(function() {
                        reconnectInterval = Math.min(30000, reconnectInterval * 1.5);  // 最大间隔30秒
                        connectWebSocket();
                    }, reconnectInterval);
                }
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket错误:', error);
            };
        }
        
        // 请求最近消息
        function requestRecentMessages(groupId) {
            if (!groupId) return;
            
            console.log(`正在请求群 ${groupId} 的最近消息`);
            const url = `/api/recent-messages/${groupId}`;
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.messages && data.messages.length > 0) {
                        console.log(`收到 ${data.messages.length} 条最近消息`);
                        
                        // 清空已处理消息集合
                        processedMessages.clear();
                        
                        // 设置延迟，逐个显示消息
                        data.messages.forEach((msg, index) => {
                            setTimeout(() => {
                                // 记录消息ID防止重复处理
                                if (msg.message_id) {
                                    processedMessages.add(msg.message_id);
                                }
                                createDanmaku(msg.content, msg.user_id, msg.message_id);
                            }, index * 300);  // 每隔300ms显示一条
                        });
                    } else {
                        console.log('没有找到最近消息或请求失败');
                    }
                })
                .catch(error => {
                    console.error('获取最近消息出错:', error);
                });
        }
        
        // 接收来自父窗口的消息
        window.addEventListener('message', function(event) {
            console.log('收到来自父窗口的消息:', event.data);
            
            if (event.data.action === 'newDanmaku') {
                // 添加新弹幕
                const message = event.data.message;
                
                // 检查是否已处理过该消息
                if (message.message_id && processedMessages.has(message.message_id)) {
                    console.log(`跳过重复消息: ${message.message_id}`);
                    return;
                }
                
                // 添加到已处理集合
                if (message.message_id) {
                    processedMessages.add(message.message_id);
                }
                
                createDanmaku(message.content, message.user_id, message.message_id);
            } else if (event.data.action === 'clearDanmaku') {
                // 清空所有弹幕
                clearDanmaku();
                // 清空已处理消息集合
                processedMessages.clear();
            } else if (event.data.action === 'showRecentMessages') {
                // 显示最近消息
                const messages = event.data.messages || [];
                
                // 清空已处理消息集合
                processedMessages.clear();
                
                // 设置延迟，逐个显示消息
                messages.forEach((msg, index) => {
                    setTimeout(() => {
                        // 记录消息ID防止重复处理
                        if (msg.message_id) {
                            processedMessages.add(msg.message_id);
                        }
                        createDanmaku(msg.content, msg.user_id, msg.message_id);
                    }, index * 300);  // 每隔300ms显示一条
                });
            } else if (event.data.action === 'applySettings') {
                // 应用设置
                const settings = event.data.settings || {};
                applySettings(settings);
            }
            
            // 通知父窗口弹幕页面已准备就绪
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({type: 'previewReady'}, '*');
            }
        });
        
        // 按键事件处理
        document.addEventListener('keydown', function(event) {
            // D键切换调试信息
            if (event.key === 'd' || event.key === 'D') {
                toggleDebug();
            }
            
            // ESC键退出全屏
            if (event.key === 'Escape' && document.fullscreenElement) {
                document.exitFullscreen();
            }
        });
        
        // 定期更新统计信息
        setInterval(updateDanmakuCount, 1000);
        
        // 初始化
        function init() {
            // 通知父窗口弹幕页面已就绪
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({type: 'previewReady'}, '*');
            }
            
            // 检查是否显示调试信息
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('debug') === 'true') {
                toggleDebug();
            }
            
            // 如果是全屏模式，自动连接WebSocket
            if (isFullscreen) {
                console.log('检测到独立窗口模式，自动连接WebSocket');
                connectWebSocket();
            } else {
                console.log('检测到嵌入模式，不自动连接WebSocket');
            }
            
            // 应用URL中的字体大小设置
            const fontSize = urlParams.get('fontSize');
            if (fontSize && !isNaN(parseInt(fontSize))) {
                danmakuFontSize = parseInt(fontSize);
                document.documentElement.style.setProperty('--danmaku-font-size', `${danmakuFontSize}px`);
            }
        }
        
        // 初始化
        init();
    </script>
</body>
</html> 